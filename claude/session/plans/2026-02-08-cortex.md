# Plan: Cortex — Persistent Memory Plugin

**Spec:** `.claude/specs/2026-02-08-cortex/spec.md`
**Created:** 2026-02-08

## Summary

Cortex is a native Claude Code plugin that silently extracts knowledge from sessions (Stop hook), surfaces ranked context at session start (Start hook), and provides semantic recall mid-session via skills. The engine is a TypeScript/bun functional core with pure ranking, decay, similarity, and surface generation modules, wrapped by thin I/O shells for SQLite, Voyage AI, Haiku API, and filesystem. Code-aware memory via prose-code pairing (prose embedded, code stored raw, linked via `source_of` edges) is the key differentiator.

---

## Architectural Decisions

### AD-1: Plugin Structure — Monorepo Engine + Plugin Shell

**Choice:** Single `cortex/` directory under `.claude/plugins/` containing both the engine (TypeScript library + CLI) and plugin shell (plugin.json, hooks, skills, commands). Engine compiles via bun, CLI entry point invoked by hook shell shims.
**Why:** Follows loom pattern exactly. Single `bun ${CLAUDE_PLUGIN_ROOT}/engine/dist/cli.js <command>` entry point avoids path resolution issues. Plugin shell references engine via `${CLAUDE_PLUGIN_ROOT}`.
**Rejected:**
- Separate engine package + plugin package -- adds npm/bun workspace complexity for no benefit in a single-user plugin
- MCP server architecture -- spec explicitly excludes (FR-115)

### AD-2: Functional Core / Imperative Shell Split

**Choice:** All ranking, decay, similarity, surface generation, extraction parsing, graph traversal, and Jaccard filtering are pure functions in `engine/src/core/`. All SQLite, HTTP, filesystem, and git operations in `engine/src/infra/`. CLI commands in `engine/src/commands/` are thin orchestrators calling core then infra.
**Why:** Achieves NFR-021 (90%+ unit testable without mocks). Pure functions compose, test trivially with fast-check property tests. I/O modules testable with in-memory SQLite / HTTP fixtures.
**Rejected:**
- OOP service classes with dependency injection -- over-engineered for CLI tool, harder to test
- Single-file scripts per command -- no code reuse, untestable business logic

### AD-3: Discriminated Unions for Domain Types

**Choice:** Model Memory, Edge, ExtractionResult, SearchResult, HookInput as TypeScript discriminated unions using `ts-pattern` for exhaustive matching. Memory status is `'active' | 'superseded' | 'archived' | 'pruned'`. Memory type is a string literal union of 8 types.
**Why:** Compiler catches missing cases. Aligns with codebase TypeScript patterns (loom `HookResult`, `TaskStatus`). ts-pattern already a dev dependency in loom.
**Rejected:**
- Plain string types with runtime validation -- no compile-time safety
- Zod schemas only -- good for parsing I/O boundaries but heavy for internal domain types

### AD-4: SQLite via better-sqlite3 (Synchronous)

**Choice:** Use `better-sqlite3` for synchronous database access. WAL mode for concurrent reads. FTS5 virtual table for keyword search. Embeddings stored as BLOBs.
**Why:** Synchronous API avoids callback/promise complexity in CLI tool. WAL handles concurrent hook invocations safely. FTS5 gives offline search with zero external deps. better-sqlite3 is the de facto bun-compatible native SQLite binding.
**Rejected:**
- sql.js (WASM) -- slower, no FTS5 without custom build, larger bundle
- Async sqlite3 -- unnecessary complexity for sequential CLI operations

### AD-5: Dual-DB with Scope Routing

**Choice:** Project DB at `.memory/cortex.db`, global DB at `~/.claude/memory/cortex-global.db`. A pure `routeScope()` function determines target DB based on LLM confidence (>0.8 = global, else project). Search queries both DBs, merges results via pure `mergeResults()`.
**Why:** Matches spec (FR-097-099). Clean separation. Global memories survive project deletion. Pure routing logic testable without DB.
**Rejected:**
- Single DB with scope column -- simpler but global memories lost when project deleted
- Three DBs (project, global, shared) -- over-engineered for v1

### AD-6: Embedding Strategy — Voyage Primary, Local Fallback

**Choice:** Voyage AI (voyage-3.5-lite, 1024d) as primary embedding service. `@huggingface/transformers` with all-MiniLM-L6-v2 (384d) as offline fallback. Two BLOB columns: `voyage_embedding`, `local_embedding`. Cosine similarity computed against whichever column is populated, preferring voyage.
**Why:** Voyage is Anthropic's embedding partner, high quality. Local fallback satisfies NFR-014 (offline support). Separate columns avoid dimension mismatch issues.
**Rejected:**
- Voyage only -- breaks offline requirement
- Local only -- lower quality hurts search relevance
- Single embedding column with dimension field -- complex serialization, hard to query

### AD-7: CLI Entry Point Pattern

**Choice:** Single CLI entry point `engine/src/cli.ts` with subcommand routing: `extract`, `generate`, `recall`, `remember`, `index-code`, `forget`, `consolidate`, `lifecycle`, `traverse`, `inspect`, `get`, `backfill`. Hook shims call `exec bun ${CLAUDE_PLUGIN_ROOT}/engine/src/cli.ts <subcommand>`.
**Why:** Follows loom CLI pattern exactly. Single entry point for all operations. Subcommands map 1:1 to skill/hook invocations. Easy to test end-to-end.
**Rejected:**
- Separate scripts per command -- harder to share config, no single entry point
- Direct bun handler imports from hooks -- brittle path resolution

### AD-8: Push Surface Cache Strategy

**Choice:** Cache push surface keyed by `(branch, cwd)` as JSON in `.memory/surface-cache/`. On generation, write both cache file and `.claude/cortex-memory.local.md`. On session start, serve cached surface if available. Invalidate on new extraction. Staleness warning if >24h old.
**Why:** Instant session startup (FR-021). Cache invalidation on extraction (FR-022). Branch-aware surfaces (FR-020). PID-based locking prevents corruption (FR-028-029).
**Rejected:**
- SQLite-based cache -- overkill for a few cached markdown files
- No cache (regenerate every time) -- violates 5s startup requirement

---

## File Structure

### Plugin Shell

```
.claude/plugins/cortex/.claude-plugin/plugin.json       -- plugin manifest
.claude/plugins/cortex/hooks/hooks.json                  -- hook definitions (Stop, SessionStart)
.claude/plugins/cortex/hooks/scripts/extract-and-generate.sh  -- Stop hook shim
.claude/plugins/cortex/hooks/scripts/load-surface.sh     -- SessionStart hook shim
.claude/plugins/cortex/commands/recall.md                -- /recall command
.claude/plugins/cortex/commands/remember.md              -- /remember command
.claude/plugins/cortex/commands/index-code.md            -- /index-code command
.claude/plugins/cortex/commands/forget.md                -- /forget command
.claude/plugins/cortex/commands/consolidate.md           -- /consolidate command
.claude/plugins/cortex/commands/inspect.md               -- /inspect command
```

### Engine Core (pure functions)

```
.claude/plugins/cortex/engine/src/core/types.ts          -- domain types (Memory, Edge, etc.)
.claude/plugins/cortex/engine/src/core/types.test.ts     -- type constructor tests
.claude/plugins/cortex/engine/src/core/ranking.ts        -- rank score formula, push surface selection
.claude/plugins/cortex/engine/src/core/ranking.test.ts   -- ranking tests + property tests
.claude/plugins/cortex/engine/src/core/decay.ts          -- confidence decay, half-life map
.claude/plugins/cortex/engine/src/core/decay.test.ts     -- decay tests + property tests
.claude/plugins/cortex/engine/src/core/similarity.ts     -- cosine similarity, Jaccard pre-filter
.claude/plugins/cortex/engine/src/core/similarity.test.ts -- similarity tests + property tests
.claude/plugins/cortex/engine/src/core/graph.ts          -- centrality, edge sanitization, BFS traversal
.claude/plugins/cortex/engine/src/core/graph.test.ts     -- graph tests
.claude/plugins/cortex/engine/src/core/surface.ts        -- push surface markdown generation, category budgets
.claude/plugins/cortex/engine/src/core/surface.test.ts   -- surface snapshot tests
.claude/plugins/cortex/engine/src/core/extraction.ts     -- prompt builder, response parser, transcript truncation
.claude/plugins/cortex/engine/src/core/extraction.test.ts -- extraction parser tests
```

### Engine Infrastructure (I/O shell)

```
.claude/plugins/cortex/engine/src/infra/db.ts            -- SQLite schema, WAL, CRUD, FTS5, checkpoint/restore
.claude/plugins/cortex/engine/src/infra/db.test.ts       -- integration tests (in-memory SQLite)
.claude/plugins/cortex/engine/src/infra/voyage.ts        -- Voyage AI HTTP client
.claude/plugins/cortex/engine/src/infra/voyage.test.ts   -- tests with HTTP fixtures
.claude/plugins/cortex/engine/src/infra/haiku.ts         -- Haiku API client (extraction, edge classification)
.claude/plugins/cortex/engine/src/infra/haiku.test.ts    -- tests with HTTP fixtures
.claude/plugins/cortex/engine/src/infra/local-embed.ts   -- @huggingface/transformers fallback
.claude/plugins/cortex/engine/src/infra/local-embed.test.ts -- integration test
.claude/plugins/cortex/engine/src/infra/git-context.ts   -- branch, commits, changed files
.claude/plugins/cortex/engine/src/infra/git-context.test.ts -- git context tests
.claude/plugins/cortex/engine/src/infra/filesystem.ts    -- file read/write, PID lock, .gitignore mgmt
.claude/plugins/cortex/engine/src/infra/filesystem.test.ts -- filesystem tests
```

### Engine Commands (thin orchestrators)

```
.claude/plugins/cortex/engine/src/commands/extract.ts     -- session-end extraction pipeline
.claude/plugins/cortex/engine/src/commands/generate.ts    -- push surface generation
.claude/plugins/cortex/engine/src/commands/recall.ts      -- semantic + keyword search
.claude/plugins/cortex/engine/src/commands/remember.ts    -- explicit memory creation
.claude/plugins/cortex/engine/src/commands/index-code.ts  -- prose-code indexing
.claude/plugins/cortex/engine/src/commands/forget.ts      -- memory archival
.claude/plugins/cortex/engine/src/commands/consolidate.ts -- duplicate detection + merge
.claude/plugins/cortex/engine/src/commands/lifecycle.ts   -- decay, archive, prune
.claude/plugins/cortex/engine/src/commands/traverse.ts    -- graph traversal
.claude/plugins/cortex/engine/src/commands/inspect.ts     -- telemetry display
.claude/plugins/cortex/engine/src/commands/backfill.ts    -- embedding queue processing
```

### Engine Entry Point + Config

```
.claude/plugins/cortex/engine/src/cli.ts                  -- CLI entry point with subcommand routing
.claude/plugins/cortex/engine/src/config.ts               -- paths, constants, env vars
.claude/plugins/cortex/engine/package.json                -- dependencies
.claude/plugins/cortex/engine/tsconfig.json               -- TypeScript config
.claude/plugins/cortex/engine/vitest.config.ts            -- test config (bun test)
```

---

## Component Design

### 1. Domain Types (`core/types.ts`)

**Responsibility:** Define all domain types as discriminated unions and branded types. Factory functions validate invariants at construction.
**Files:** `engine/src/core/types.ts`, `engine/src/core/types.test.ts`
**Interface:**

```typescript
// Memory types
type MemoryType = 'architecture' | 'decision' | 'pattern' | 'gotcha'
  | 'context' | 'progress' | 'code_description' | 'code';

type MemoryStatus = 'active' | 'superseded' | 'archived' | 'pruned';
type MemoryScope = 'project' | 'global';
type SourceType = 'extraction' | 'manual' | 'code_index';

interface Memory {
  readonly id: string;
  readonly content: string;
  readonly summary: string;
  readonly memory_type: MemoryType;
  readonly scope: MemoryScope;
  readonly voyage_embedding: Float64Array | null;
  readonly local_embedding: Float32Array | null;
  readonly confidence: number;      // 0-1
  readonly priority: number;        // 1-10
  readonly pinned: boolean;
  readonly source_type: SourceType;
  readonly source_session: string;
  readonly source_context: string;  // JSON: branch, commits, files
  readonly tags: readonly string[];
  readonly access_count: number;
  readonly last_accessed_at: string;
  readonly created_at: string;
  readonly updated_at: string;
  readonly status: MemoryStatus;
}

// Edge types
type EdgeRelation = 'relates_to' | 'derived_from' | 'contradicts'
  | 'exemplifies' | 'refines' | 'supersedes' | 'source_of';
type EdgeStatus = 'active' | 'suggested';

interface Edge {
  readonly id: string;
  readonly source_id: string;
  readonly target_id: string;
  readonly relation_type: EdgeRelation;
  readonly strength: number;        // 0-1
  readonly bidirectional: boolean;
  readonly status: EdgeStatus;
  readonly created_at: string;
}

// Extraction types
interface ExtractionCheckpoint {
  readonly id: string;
  readonly session_id: string;
  readonly cursor_position: number;
  readonly extracted_at: string;
}

// Hook input
interface StopHookInput {
  readonly session_id: string;
  readonly transcript_path: string;
  readonly cwd: string;
}

// Search result
interface SearchResult {
  readonly memory: Memory;
  readonly score: number;
  readonly source: 'project' | 'global';
  readonly related: readonly Memory[];
}
```

**Depends on:** none

### 2. Ranking Engine (`core/ranking.ts`)

**Responsibility:** Compute composite rank scores. Select memories for push surface respecting category budgets. Merge search results from dual DBs.
**Files:** `engine/src/core/ranking.ts`, `engine/src/core/ranking.test.ts`
**Interface:**

```typescript
// Pure: (memory, maxLog) => number
function computeRank(memory: Memory, maxAccessLog: number): number;
// rank = (confidence * 0.5) + (priority/10 * 0.2) + (centrality * 0.15) + (log(access+1)/maxLog * 0.15)

// Pure: select memories for surface within token budget
function selectForSurface(
  memories: readonly Memory[],
  branch: string,
  maxTokens: number
): readonly Memory[];

// Pure: merge project + global results, deduplicate, re-rank
function mergeResults(
  project: readonly SearchResult[],
  global: readonly SearchResult[],
  limit: number
): readonly SearchResult[];
```

**Depends on:** `core/types.ts`

### 3. Decay Engine (`core/decay.ts`)

**Responsibility:** Compute confidence decay based on memory type and age. Determine archive/prune transitions.
**Files:** `engine/src/core/decay.ts`, `engine/src/core/decay.test.ts`
**Interface:**

```typescript
// Half-life map (pure constant)
const HALF_LIFE_DAYS: Record<MemoryType, number | null>;
// null = stable (no decay)

// Pure: compute decayed confidence
function decayConfidence(memory: Memory, now: Date): number;
// Applies: pinned = no decay, access_count >10 = 2x half-life, centrality >0.5 = 2x half-life

// Pure: determine lifecycle transition
type LifecycleAction =
  | { action: 'none' }
  | { action: 'archive'; reason: string }
  | { action: 'prune'; reason: string }
  | { action: 'exempt'; reason: string };

function determineLifecycle(
  memory: Memory,
  decayedConfidence: number,
  daysBelowThreshold: number,
  centrality: number,
  now: Date
): LifecycleAction;
```

**Depends on:** `core/types.ts`

### 4. Similarity Engine (`core/similarity.ts`)

**Responsibility:** Cosine similarity between embedding vectors. Jaccard pre-filter for cheap similarity estimation. Batch search across memory collections.
**Files:** `engine/src/core/similarity.ts`, `engine/src/core/similarity.test.ts`
**Interface:**

```typescript
// Pure: cosine similarity between two vectors
function cosineSimilarity(a: Float64Array | Float32Array, b: Float64Array | Float32Array): number;

// Pure: normalize vector in place
function normalize(v: Float64Array | Float32Array): Float64Array | Float32Array;

// Pure: Jaccard similarity between two token sets
function jaccardSimilarity(a: ReadonlySet<string>, b: ReadonlySet<string>): number;

// Pure: tokenize text for Jaccard
function tokenize(text: string): ReadonlySet<string>;

// Pure: classify similarity into action
type SimilarityAction =
  | { action: 'ignore' }             // < 0.1
  | { action: 'relate'; strength: number }  // 0.1-0.5
  | { action: 'suggest'; strength: number } // 0.4-0.5 (also creates suggested edge)
  | { action: 'consolidate' };        // > 0.5

function classifySimilarity(score: number): SimilarityAction;

// Pure: Jaccard pre-filter to skip unnecessary embedding comparisons
type JaccardVerdict = 'definitely_similar' | 'maybe' | 'definitely_different';
function jaccardPreFilter(score: number): JaccardVerdict;
// >0.6 = definitely_similar, <0.1 = definitely_different, else maybe
```

**Depends on:** `core/types.ts`

### 5. Graph Engine (`core/graph.ts`)

**Responsibility:** BFS traversal, in-degree centrality computation, edge type normalization, edge deduplication.
**Files:** `engine/src/core/graph.ts`, `engine/src/core/graph.test.ts`
**Interface:**

```typescript
// Pure: compute in-degree centrality for a memory
function computeCentrality(memoryId: string, edges: readonly Edge[]): number;

// Pure: normalize edge type aliases
function sanitizeEdgeType(raw: string): EdgeRelation | null;
// 'derives' -> 'derived_from', 'contradict' -> 'contradicts', etc.

// Pure: BFS traversal from a start node
interface TraversalOptions {
  readonly maxDepth: number;         // default 2
  readonly edgeTypes?: readonly EdgeRelation[];
  readonly direction?: 'outgoing' | 'incoming' | 'both';
  readonly minStrength?: number;
}

interface TraversalResult {
  readonly memoryId: string;
  readonly depth: number;
  readonly path: readonly string[];  // edge IDs traversed
}

function traverseGraph(
  startId: string,
  edges: readonly Edge[],
  options: TraversalOptions
): readonly TraversalResult[];

// Pure: check for duplicate edge
function isDuplicateEdge(
  edge: Pick<Edge, 'source_id' | 'target_id' | 'relation_type'>,
  existing: readonly Edge[]
): boolean;
```

**Depends on:** `core/types.ts`

### 6. Surface Generator (`core/surface.ts`)

**Responsibility:** Generate push surface markdown from ranked memories. Enforce per-category line budgets with overflow and redistribution. Write between CORTEX_MEMORY markers.
**Files:** `engine/src/core/surface.ts`, `engine/src/core/surface.test.ts`
**Interface:**

```typescript
// Category line budgets
const CATEGORY_BUDGETS: Record<MemoryType, number>;
// architecture: 25, decision: 25, pattern: 25, gotcha: 20, progress: 30, context: 15, code_description: 10, code: 0

// Pure: generate push surface markdown
function generateSurface(
  memories: readonly Memory[],
  branch: string,
  staleness: { stale: boolean; age_hours: number } | null
): string;

// Pure: wrap content in markers
function wrapInMarkers(content: string): string;
// <!-- CORTEX_MEMORY_START --> ... <!-- CORTEX_MEMORY_END -->

// Pure: estimate token count (word-based approximation)
function estimateTokens(text: string): number;
```

**Depends on:** `core/types.ts`, `core/ranking.ts`

### 7. Extraction Parser (`core/extraction.ts`)

**Responsibility:** Build Haiku extraction prompts from transcripts. Parse structured extraction responses into Memory candidates. Truncate transcripts for large sessions. Resume from cursor position.
**Files:** `engine/src/core/extraction.ts`, `engine/src/core/extraction.test.ts`
**Interface:**

```typescript
// Pure: truncate transcript to fit context window
function truncateTranscript(content: string, maxBytes: number, cursor: number): { text: string; newCursor: number };

// Pure: build extraction prompt from transcript + git context
interface GitContext {
  readonly branch: string;
  readonly recent_commits: readonly string[];
  readonly changed_files: readonly string[];
}

function buildExtractionPrompt(transcript: string, gitContext: GitContext): string;

// Pure: parse Haiku extraction response into memory candidates
interface MemoryCandidate {
  readonly content: string;
  readonly summary: string;
  readonly memory_type: MemoryType;
  readonly scope: MemoryScope;
  readonly confidence: number;
  readonly priority: number;
  readonly tags: readonly string[];
}

function parseExtractionResponse(response: string): readonly MemoryCandidate[];

// Pure: build embedding text with metadata prefix
function buildEmbeddingText(memory: Pick<Memory, 'memory_type' | 'summary'>, projectName: string): string;
// "[memory_type] [project:name] summary"
```

**Depends on:** `core/types.ts`

### 8. Database Layer (`infra/db.ts`)

**Responsibility:** SQLite schema creation (WAL, FTS5), CRUD for memories/edges/extractions, checkpoint/restore, embedding BLOB serialization, scope routing.
**Files:** `engine/src/infra/db.ts`, `engine/src/infra/db.test.ts`
**Interface:**

```typescript
// I/O: open or create database with schema
function openDatabase(path: string): Database;

// I/O: CRUD operations
function insertMemory(db: Database, memory: Memory): string;
function updateMemory(db: Database, id: string, fields: Partial<Memory>): void;
function getMemory(db: Database, id: string): Memory | null;
function searchByEmbedding(db: Database, embedding: Float64Array, limit: number): readonly Memory[];
function searchByKeyword(db: Database, query: string, limit: number): readonly Memory[];
function getActiveMemories(db: Database): readonly Memory[];

function insertEdge(db: Database, edge: Omit<Edge, 'id' | 'created_at'>): string;
function getEdgesForMemory(db: Database, memoryId: string): readonly Edge[];
function getAllEdges(db: Database): readonly Edge[];

function getExtractionCheckpoint(db: Database, sessionId: string): ExtractionCheckpoint | null;
function saveExtractionCheckpoint(db: Database, checkpoint: Omit<ExtractionCheckpoint, 'id'>): void;

// I/O: checkpoint/restore for consolidation safety
function createCheckpoint(db: Database): string;  // returns checkpoint path
function restoreCheckpoint(db: Database, checkpointPath: string): void;

// I/O: scope routing
function routeToDatabase(scope: MemoryScope, projectDbPath: string, globalDbPath: string): Database;
```

**Depends on:** `core/types.ts`

### 9. API Clients (`infra/voyage.ts`, `infra/haiku.ts`, `infra/local-embed.ts`)

**Responsibility:** HTTP clients for Voyage AI embeddings and Haiku API extraction/classification. Local embedding fallback.
**Files:** `engine/src/infra/voyage.ts`, `engine/src/infra/haiku.ts`, `engine/src/infra/local-embed.ts` + tests
**Interface:**

```typescript
// voyage.ts
function embedTexts(texts: readonly string[], apiKey: string): Promise<Float64Array[]>;
function isVoyageAvailable(apiKey: string | undefined): boolean;

// haiku.ts
function extractMemories(prompt: string, apiKey: string): Promise<string>;
function classifyEdges(pairs: readonly MemoryPair[], apiKey: string): Promise<readonly EdgeClassification[]>;

// local-embed.ts
function embedLocal(text: string): Promise<Float32Array>;
function isLocalModelAvailable(): boolean;
```

**Depends on:** `core/types.ts`

### 10. Git Context (`infra/git-context.ts`)

**Responsibility:** Extract current branch, recent commits, and changed files from git. Follows loom `utils/git.ts` patterns.
**Files:** `engine/src/infra/git-context.ts`, `engine/src/infra/git-context.test.ts`
**Interface:**

```typescript
function getGitContext(cwd: string): GitContext;
function getCurrentBranch(cwd: string): string;
```

**Depends on:** `core/extraction.ts` (GitContext type)

### 11. Filesystem (`infra/filesystem.ts`)

**Responsibility:** PID-based file locking, surface file write with markers, .gitignore management, telemetry logging.
**Files:** `engine/src/infra/filesystem.ts`, `engine/src/infra/filesystem.test.ts`
**Interface:**

```typescript
function writeSurface(path: string, content: string, lockDir: string): void;
function readSurface(path: string): string | null;
function ensureGitignored(projectRoot: string, patterns: readonly string[]): void;
function writeTelemetry(path: string, data: Record<string, unknown>): void;

// PID lock (follows loom lock.ts pattern)
function withPidLock<T>(lockPath: string, fn: () => T): T;
function isStalePidLock(lockPath: string): boolean;
```

**Depends on:** none

### 12. CLI Entry Point (`cli.ts`)

**Responsibility:** Parse subcommand + args, read stdin, dispatch to command modules, handle errors, write structured output.
**Files:** `engine/src/cli.ts`
**Interface:**

```typescript
// Follows loom cli.ts pattern
// Subcommands: extract, generate, recall, remember, index-code, forget,
//              consolidate, lifecycle, traverse, inspect, get, backfill
```

**Depends on:** all command modules

---

## Data Flow

### Session End (Stop Hook)

```
stdin JSON { session_id, transcript_path, cwd }
  -> read transcript file (I/O)
  -> get extraction checkpoint (I/O)
  -> truncateTranscript (pure)
  -> getGitContext (I/O)
  -> buildExtractionPrompt (pure)
  -> Haiku extract (I/O)
  -> parseExtractionResponse (pure)
  -> for each candidate:
       -> insertMemory (I/O)
       -> embedTexts via Voyage or queue (I/O)
       -> tokenize + jaccardPreFilter (pure)
       -> for "maybe" range: cosineSimilarity (pure)
       -> classifySimilarity (pure)
       -> insertEdge / flag consolidation (I/O)
  -> computeCentrality for affected memories (pure)
  -> saveExtractionCheckpoint (I/O)
  -> apply lifecycle: decayConfidence (pure) -> determineLifecycle (pure) -> update DB (I/O)
  -> check consolidation trigger (extraction count >10 or active >80)
  -> selectForSurface (pure)
  -> generateSurface (pure)
  -> writeSurface with PID lock (I/O)
  -> cache surface keyed by (branch, cwd) (I/O)
  -> writeTelemetry (I/O)
```

### Session Start (SessionStart Hook)

```
  -> read cached surface for (branch, cwd) (I/O)
  -> if cache exists and <24h old: write to .claude/cortex-memory.local.md (I/O)
  -> if cache >24h old: write with staleness warning (I/O)
  -> if no cache: no-op
  -> backfill pending embeddings in background (I/O)
```

### /recall Query

```
query text
  -> buildEmbeddingText with metadata prefix (pure)
  -> embedTexts via Voyage (I/O) OR FTS5 keyword search (I/O)
  -> search project DB + global DB (I/O)
  -> optional --branch filter (pure)
  -> mergeResults (pure)
  -> for top results: follow source_of edges (I/O)
  -> traverseGraph depth 2 for related (pure over edge data from I/O)
  -> update access stats (I/O)
  -> format and output
```

---

## Implementation Phases

### Phase 1: Foundation (no dependencies)

Build core types, pure domain functions, and project scaffold. Everything in this phase has zero external dependencies and is fully unit testable.

- Define all domain types as discriminated unions with factory functions
- Implement ranking formula as pure function
- Implement decay engine with half-life map and lifecycle transitions
- Implement similarity engine (cosine, Jaccard, classification)
- Implement graph engine (centrality, BFS traversal, edge sanitization)
- Implement extraction parser (prompt builder, response parser, transcript truncation)
- Implement surface generator (markdown, category budgets, token estimation, markers)
- Set up project scaffold (package.json, tsconfig.json, vitest config)
- **Files:** all `engine/src/core/*.ts` + tests, `engine/package.json`, `engine/tsconfig.json`, `engine/vitest.config.ts`

### Phase 2: Infrastructure (depends on Phase 1)

Build all I/O modules that interact with SQLite, HTTP APIs, git, and filesystem.

- Implement SQLite database layer (schema, WAL, FTS5, CRUD, checkpoint/restore, BLOB serialization)
- Implement Voyage AI HTTP client (embed texts, batch support)
- Implement Haiku API client (extraction, edge classification)
- Implement local embedding fallback (@huggingface/transformers)
- Implement git context extraction (branch, commits, changed files)
- Implement filesystem module (PID lock, surface write, .gitignore, telemetry)
- **Files:** all `engine/src/infra/*.ts` + tests

### Phase 3: Commands (depends on Phase 1 + 2)

Build CLI command orchestrators that wire core logic to infrastructure.

- Implement extract command (full session-end pipeline)
- Implement generate command (push surface generation + cache)
- Implement recall command (semantic search + FTS5 fallback + graph traversal)
- Implement remember command (explicit memory creation + embedding queue)
- Implement index-code command (prose-code pairing with source_of edges)
- Implement forget command (archive by ID or fuzzy query)
- Implement consolidate command (similarity detection, merge flow, checkpoint/rollback)
- Implement lifecycle command (decay, archive, prune)
- Implement traverse command (graph BFS from memory ID)
- Implement inspect command (telemetry display)
- Implement backfill command (process pending embedding queue)
- Build CLI entry point with subcommand routing
- **Files:** all `engine/src/commands/*.ts`, `engine/src/cli.ts`, `engine/src/config.ts`

### Phase 4: Plugin Integration (depends on Phase 3)

Wire engine to Claude Code plugin system via hooks, commands, and plugin manifest.

- Create plugin.json manifest
- Create hooks.json with Stop and SessionStart hook definitions
- Create hook shell shims (extract-and-generate.sh, load-surface.sh)
- Create command markdown files (/recall, /remember, /index-code, /forget, /consolidate, /inspect)
- Ensure .memory/ and .claude/cortex-memory.local.md are gitignored
- Write end-to-end integration tests
- **Files:** all `.claude/plugins/cortex/` shell files, hook scripts, command markdown

---

## Testing Strategy

| Component | Unit Tests | Integration Tests | Property Tests |
|-----------|-----------|-------------------|----------------|
| `core/types.ts` | Factory validation, type guards | -- | -- |
| `core/ranking.ts` | Score computation, surface selection, result merge | -- | rank non-negative + bounded [0,1]; higher priority = higher rank (monotonic); branch boost increases rank |
| `core/decay.ts` | Decay per type, pinned immunity, modifier doubling | -- | monotonic decay over time; pinned confidence stable; decayed <= original; half-life halves confidence |
| `core/similarity.ts` | Cosine, Jaccard, classification thresholds | -- | cosine symmetry (sim(a,b) == sim(b,a)); Jaccard in [0,1]; identical vectors = 1.0; orthogonal = 0.0 |
| `core/graph.ts` | Centrality, BFS depth limits, edge sanitization, dedup | -- | traversal never exceeds maxDepth; visited set prevents cycles; centrality >= 0 |
| `core/surface.ts` | Markdown generation, category budgets, token estimation | -- | token estimate within 20% of actual; total content <= maxTokens + 10% overflow |
| `core/extraction.ts` | Prompt building, response parsing, transcript truncation | -- | truncation preserves cursor monotonicity; parsed candidates have valid types |
| `infra/db.ts` | -- | In-memory SQLite: CRUD, FTS5 search, checkpoint/restore, WAL | -- |
| `infra/voyage.ts` | -- | HTTP fixture: embed response shape | -- |
| `infra/haiku.ts` | -- | HTTP fixture: extraction response parsing | -- |
| `infra/local-embed.ts` | -- | Model loading + embedding shape validation | -- |
| `infra/git-context.ts` | -- | Temp git repo: branch, commits, files | -- |
| `infra/filesystem.ts` | -- | Temp dir: PID lock acquire/release, stale detection, surface write | -- |
| commands (e2e) | -- | Full pipeline: extract -> generate -> recall -> forget with in-memory DB | -- |

---

## Security & NFR Notes

- **Security:** API keys read from `ANTHROPIC_API_KEY` and `VOYAGE_API_KEY` env vars only (NFR-019). Raw code content never sent to embedding API (FR-053, NFR-018). Telemetry logs timing/counts only, no raw transcripts or memory content (NFR-020). All user input to SQL goes through prepared statements (better-sqlite3 parameterized queries).
- **Performance:** Jaccard pre-filter reduces Voyage API calls for large stores (FR-061). SQLite WAL mode for concurrent reads (FR-100). Push surface cached for instant startup (FR-019). Extraction has 30s timeout with transcript truncation as escape valve (NFR-001). Embedding queue for offline/async processing (FR-045, NFR-016).
- **Reliability:** All hook errors caught and logged, never block session (NFR-009, NFR-010). Database checkpoints before consolidation (NFR-013). PID-based file locking with stale detection (FR-028-029). WAL for corruption recovery (NFR-012).
- **Cost:** Haiku extraction ~$0.001/session, Voyage embeddings within free tier (200M tokens/month), total <$0.05/day for 10 sessions (NFR-007).

---

## Verification

1. `cd .claude/plugins/cortex/engine && bun test` -- all unit + integration tests pass
2. `cd .claude/plugins/cortex/engine && bunx tsc --noEmit` -- type check passes
3. Manual: start Claude Code session in test project, end session, verify `.claude/cortex-memory.local.md` generated with CORTEX_MEMORY markers
4. Manual: `/recall "test query"` returns results from project + global DB
5. Manual: `/remember "test memory" --type=decision --priority=8` creates memory, appears in next push surface
6. Manual: `/inspect` shows extraction count, memory count, embedding queue size

---

## Unresolved Questions

- `@huggingface/transformers` bun compat? WASM backend needed? May need to test early in Phase 2.
- `better-sqlite3` bun native addon -- confirmed on linux x86_64? Darwin arm64?
- Voyage API batch limits -- max texts per request? Affects `embedTexts` batching.
- Stop hook -- verify actual stdin payload shape matches `{ session_id, transcript_path, cwd }`.
- Embedding metadata prefix -- does `[type] [project:X]` actually improve Voyage clustering? Low-risk to include, can measure later.
- Consolidation trigger thresholds (10 extractions, 80 active) -- tunable via config or hardcoded v1?
